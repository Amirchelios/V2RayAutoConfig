#!/usr/bin/env python3
"""
üîó Daily TrustLink Tester - ÿ®ÿ±ŸÜÿßŸÖŸá ÿ±Ÿàÿ≤ÿßŸÜŸá ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™ Ÿà ŸÅ€åŸÑÿ™ÿ± ⁄©ÿ±ÿØŸÜ ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß€å TrustLink
ÿß€åŸÜ ÿ®ÿ±ŸÜÿßŸÖŸá Ÿáÿ± ÿ±Ÿàÿ≤ ÿØÿ± ÿ≥ÿßÿπÿ™ 00:00 ÿßÿ¨ÿ±ÿß ŸÖ€å‚Äåÿ¥ŸàÿØ Ÿà ÿ®Ÿáÿ™ÿ±€åŸÜ 10 ⁄©ÿßŸÜŸÅ€å⁄Ø ÿ±ÿß ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿ≥ÿ±ÿπÿ™ Ÿà ÿßÿ™ÿµÿßŸÑ ŸÜ⁄ØŸá ŸÖ€å‚ÄåÿØÿßÿ±ÿØ
"""

import os
import sys
import time
import json
import logging
import asyncio
try:
    import aiohttp  # optional in local env
except Exception:
    aiohttp = None
import hashlib
import subprocess
import tempfile
import shutil
from datetime import datetime, timedelta
from typing import Set, List, Dict, Optional, Tuple
from urllib.parse import urlparse
import re
import platform
import zipfile
import base64

# ÿ™ŸÜÿ∏€åŸÖÿßÿ™
TRUSTLINK_FILE = "../trustlink/trustlink.txt"
TESTED_FILE = "output/trustlink_tested.txt"
TEST_RESULTS_FILE = "output/.test_results.json"
LOG_FILE = "logs/daily_tester.log"
XRAY_DIR = "../Files/xray-bin"
XRAY_BIN = None

# Ÿæÿ±Ÿàÿ™⁄©ŸÑ‚ÄåŸáÿß€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿ¥ÿØŸá ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™
SUPPORTED_PROTOCOLS = {
    "vmess://", "vless://", "trojan://", "ss://"
}

# ÿ™ŸÜÿ∏€åŸÖÿßÿ™ ÿ™ÿ≥ÿ™
TEST_TIMEOUT = 10  # ÿ´ÿßŸÜ€åŸá
CONCURRENT_TESTS = 5
DOWNLOAD_TEST_SIZE = 1024 * 1024  # 1MB
KEEP_BEST_COUNT = 10

class DailyTrustLinkTester:
    """⁄©ŸÑÿßÿ≥ ÿßÿµŸÑ€å ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá TrustLink"""
    
    def __init__(self):
        self.session: Optional[aiohttp.ClientSession] = None
        self.test_results: Dict[str, Dict] = {}
        self.best_configs: List[Tuple[str, float]] = []
        self.xray_bin = None
        self.setup_logging()
        
    def setup_logging(self):
        """ÿ™ŸÜÿ∏€åŸÖ ÿ≥€åÿ≥ÿ™ŸÖ logging"""
        try:
            os.makedirs("logs", exist_ok=True)
            os.makedirs("output", exist_ok=True)
            
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[
                    logging.FileHandler(LOG_FILE, encoding='utf-8'),
                    logging.StreamHandler(sys.stdout)
                ]
            )
        except Exception as e:
            print(f"ÿÆÿ∑ÿß ÿØÿ± ÿß€åÿ¨ÿßÿØ ÿØÿß€åÿ±⁄©ÿ™Ÿàÿ±€å logs: {e}")
            logging.basicConfig(
                level=logging.INFO,
                format='%(asctime)s - %(levelname)s - %(message)s',
                handlers=[logging.StreamHandler(sys.stdout)]
            )
    
    def ensure_xray_binary(self):
        """ÿßÿ∑ŸÖ€åŸÜÿßŸÜ ÿßÿ≤ Ÿàÿ¨ŸàÿØ ŸÅÿß€åŸÑ ÿßÿ¨ÿ±ÿß€å€å Xray ÿØÿ± ⁄ÜŸÜÿØ ŸÖÿ≥€åÿ± ŸÖŸÖ⁄©ŸÜ"""
        global XRAY_BIN
        
        try:
            xray_name = "xray.exe" if platform.system() == "Windows" else "xray"
            script_dir = os.path.dirname(os.path.abspath(__file__))
            candidates = [
                os.path.join(XRAY_DIR, xray_name),
                os.path.join(script_dir, "xray-bin", xray_name),
                os.path.join(os.getcwd(), "xray-bin", xray_name),
                shutil.which(xray_name)
            ]
            
            for path in candidates:
                if path and os.path.exists(path):
                    XRAY_BIN = path
                    self.xray_bin = path
                    logging.info(f"Xray binary found: {XRAY_BIN}")
                    return True
            
            logging.warning("Xray binary not found in expected locations")
            return False
        except Exception as e:
            logging.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å Xray: {e}")
            return False
    
    async def create_session(self):
        """ÿß€åÿ¨ÿßÿØ session ÿ®ÿ±ÿß€å HTTP requests"""
        if aiohttp is None:
            logging.warning("aiohttp ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™ÿõ ÿßÿ≤ session ÿπÿ®Ÿàÿ± ŸÖ€å‚Äå⁄©ŸÜ€åŸÖ")
            return
        if self.session is None or self.session.closed:
            timeout = aiohttp.ClientTimeout(total=TEST_TIMEOUT, connect=5, sock_read=TEST_TIMEOUT)
            self.session = aiohttp.ClientSession(timeout=timeout)
            logging.info("Session ÿ¨ÿØ€åÿØ ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™ ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ")
    
    async def close_session(self):
        """ÿ®ÿ≥ÿ™ŸÜ session"""
        if aiohttp is None:
            return
        if self.session and not self.session.closed:
            await self.session.close()
            logging.info("Session ÿ™ÿ≥ÿ™ ÿ®ÿ≥ÿ™Ÿá ÿ¥ÿØ")
    
    def load_trustlink_configs(self) -> List[str]:
        """ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß€å TrustLink"""
        try:
            if not os.path.exists(TRUSTLINK_FILE):
                logging.error(f"ŸÅÿß€åŸÑ TrustLink €åÿßŸÅÿ™ ŸÜÿ¥ÿØ: {TRUSTLINK_FILE}")
                return []
            
            with open(TRUSTLINK_FILE, 'r', encoding='utf-8') as f:
                lines = f.readlines()
                valid_configs = []
                
                for line in lines:
                    line = line.strip()
                    if line and not line.startswith('#') and self.is_valid_config(line):
                        valid_configs.append(line)
                
                logging.info(f"{len(valid_configs)} ⁄©ÿßŸÜŸÅ€å⁄Ø ŸÖÿπÿ™ÿ®ÿ± ÿßÿ≤ TrustLink ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ¥ÿØ")
                return valid_configs
                
        except Exception as e:
            logging.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß€å TrustLink: {e}")
            return []
    
    def is_valid_config(self, config: str) -> bool:
        """ÿ®ÿ±ÿ±ÿ≥€å ÿßÿπÿ™ÿ®ÿßÿ± ⁄©ÿßŸÜŸÅ€å⁄Ø"""
        if not config or len(config.strip()) < 10:
            return False
        
        config_lower = config.lower().strip()
        return any(config_lower.startswith(protocol) for protocol in SUPPORTED_PROTOCOLS)
    
    def create_config_hash(self, config: str) -> str:
        """ÿß€åÿ¨ÿßÿØ hash ÿ®ÿ±ÿß€å ⁄©ÿßŸÜŸÅ€å⁄Ø"""
        return hashlib.md5(config.strip().encode('utf-8')).hexdigest()[:8]
    
    async def test_config_connection(self, config: str) -> Dict:
        """ÿ™ÿ≥ÿ™ ÿßÿ™ÿµÿßŸÑ ⁄©ÿßŸÜŸÅ€å⁄Ø"""
        config_hash = self.create_config_hash(config)
        result = {
            "config": config,
            "hash": config_hash,
            "success": False,
            "latency": None,
            "download_speed": None,
            "error": None,
            "protocol": self.get_protocol(config)
        }
        
        try:
            host, ports = self.extract_server_info(config)
            if host and ports:
                for port in ports:
                    start_time = time.time()
                    ok = await self.tcp_ping(host, port)
                    if ok:
                        latency = (time.time() - start_time) * 1000.0
                        result["success"] = True
                        result["latency"] = latency
                        result["download_speed"] = await self.test_download_speed(config)
                        logging.info(f"‚úÖ ÿ™ÿ≥ÿ™ ŸÖŸàŸÅŸÇ: {config_hash} - {host}:{port} - Latency: {latency:.1f}ms")
                        break
                if not result["success"]:
                    result["error"] = "TCP connect failed"
                    logging.warning(f"‚ùå ÿ™ÿ≥ÿ™ ŸÜÿßŸÖŸàŸÅŸÇ: {config_hash} - {host}")
            else:
                result["error"] = "Failed to extract host/port"
                logging.warning(f"‚ùå ⁄©ÿßŸÜŸÅ€å⁄Ø ŸÜÿßŸÖÿπÿ™ÿ®ÿ±: {config_hash}")
        except Exception as e:
            result["error"] = str(e)
            logging.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿ™ÿ≥ÿ™ {config_hash}: {e}")
        
        return result
    
    def extract_server_address(self, config: str) -> Optional[str]:
        """ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ÿ¢ÿØÿ±ÿ≥ ÿ≥ÿ±Ÿàÿ± ÿßÿ≤ ⁄©ÿßŸÜŸÅ€å⁄Ø (ŸÇÿØ€åŸÖ€å) - ÿ®ÿ±ÿß€å ÿ≥ÿßÿ≤⁄Øÿßÿ±€å ÿ®ÿßŸÇ€å ŸÖÿßŸÜÿØŸá"""
        host, ports = self.extract_server_info(config)
        return host
    
    def extract_server_info(self, config: str) -> Tuple[Optional[str], List[int]]:
        """ÿßÿ≥ÿ™ÿÆÿ±ÿßÿ¨ ŸÖ€åÿ≤ÿ®ÿßŸÜ Ÿà ŸæŸàÿ±ÿ™(Ÿáÿß) ÿßÿ≤ ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß€å Ÿæÿ¥ÿ™€åÿ®ÿßŸÜ€å ÿ¥ÿØŸá"""
        try:
            cfg = config.strip()
            lower = cfg.lower()
            # ÿßŸàŸÑŸà€åÿ™: ÿß⁄Øÿ± ŸæŸàÿ±ÿ™ ÿØÿ± ⁄©ÿßŸÜŸÅ€å⁄Ø ŸÖÿ¥ÿÆÿµ ÿ®ŸàÿØ ŸáŸÖÿßŸÜ ÿ±ÿß ÿ®ÿ±⁄Øÿ±ÿØÿßŸÜ
            def default_ports(protocol: str) -> List[int]:
                if protocol in ("vless", "vmess", "trojan"):
                    return [443, 80, 8443, 2053, 2083, 2096, 2087, 20086, 8080]
                if protocol == "shadowsocks":
                    return [8388, 443, 80, 8443, 8080]
                return [443, 80]
            
            if lower.startswith("vmess://"):
                data_b64 = cfg.split("vmess://", 1)[1]
                try:
                    padded = data_b64 + "=" * ((4 - len(data_b64) % 4) % 4)
                    decoded = base64.b64decode(padded).decode("utf-8", errors="ignore")
                    vm = json.loads(decoded)
                    host = vm.get("add") or vm.get("address") or ""
                    port_raw = vm.get("port")
                    port = None
                    if isinstance(port_raw, int):
                        port = port_raw
                    elif isinstance(port_raw, str) and port_raw.isdigit():
                        port = int(port_raw)
                    ports = [port] if port else default_ports("vmess")
                    return (host, ports) if host else (None, [])
                except Exception:
                    return (None, [])
            
            if lower.startswith("vless://") or lower.startswith("trojan://"):
                p = urlparse(cfg)
                host = p.hostname
                port = p.port
                ports = [port] if port else default_ports("vless")
                return (host, ports) if host else (None, [])
            
            if lower.startswith("ss://"):
                # ÿ™ŸÑÿßÿ¥ ÿ®ÿ±ÿß€å parse ŸÖÿ≥ÿ™ŸÇ€åŸÖ
                p = urlparse(cfg)
                if p.hostname:
                    host = p.hostname
                    port = p.port
                    ports = [port] if port else default_ports("shadowsocks")
                    return (host, ports)
                # ÿ≠ÿßŸÑÿ™ base64
                raw = cfg.split("ss://", 1)[1]
                raw = raw.split("#", 1)[0]
                raw = raw.split("?", 1)[0]
                try:
                    padded = raw + "=" * ((4 - len(raw) % 4) % 4)
                    decoded = base64.urlsafe_b64decode(padded).decode("utf-8", errors="ignore")
                    # expected: method:password@host:port
                    after_at = decoded.rsplit("@", 1)[-1]
                    if ":" in after_at:
                        host, port_str = after_at.rsplit(":", 1)
                        port = int(port_str) if port_str.isdigit() else None
                        ports = [port] if port else default_ports("shadowsocks")
                        return (host, ports)
                except Exception:
                    return (None, [])
            
            return (None, [])
        except Exception:
            return (None, [])
    
    async def ping_server(self, server_address: str) -> bool:
        """Deprecated: ping ⁄©ÿ±ÿØŸÜ ÿ≥ÿ±Ÿàÿ± ÿ®ÿß HTTP - ÿ®ÿ¨ÿß€å ÿ¢ŸÜ ÿßÿ≤ tcp_ping ÿßÿ≥ÿ™ŸÅÿßÿØŸá ÿ¥ŸàÿØ"""
        try:
            return False
        except Exception:
            return False
    
    async def tcp_ping(self, host: str, port: int, timeout_sec: int = 3) -> bool:
        """ÿ™ŸÑÿßÿ¥ ÿ®ÿ±ÿß€å ÿßÿ™ÿµÿßŸÑ TCP ÿ®Ÿá ŸÖ€åÿ≤ÿ®ÿßŸÜ/ŸæŸàÿ±ÿ™ ÿ®ÿß timeout"""
        try:
            conn = asyncio.open_connection(host, port)
            reader, writer = await asyncio.wait_for(conn, timeout=timeout_sec)
            try:
                writer.close()
                if hasattr(writer, "wait_closed"):
                    await writer.wait_closed()
            except Exception:
                pass
            return True
        except Exception:
            return False
    
    def get_protocol(self, config: str) -> str:
        """ÿ™ÿ¥ÿÆ€åÿµ Ÿæÿ±Ÿàÿ™⁄©ŸÑ ⁄©ÿßŸÜŸÅ€å⁄Ø"""
        config_lower = config.lower().strip()
        if config_lower.startswith("vmess://"):
            return "vmess"
        elif config_lower.startswith("vless://"):
            return "vless"
        elif config_lower.startswith("trojan://"):
            return "trojan"
        elif config_lower.startswith("ss://"):
            return "shadowsocks"
        else:
            return "unknown"
    
    async def test_download_speed(self, config_file: str) -> float:
        """ÿ™ÿ≥ÿ™ ÿ≥ÿ±ÿπÿ™ ÿØÿßŸÜŸÑŸàÿØ (ÿ≥ÿßÿØŸá ÿ¥ÿØŸá)"""
        # ÿ®ÿ±ÿß€å ÿ≥ÿßÿØ⁄Ø€åÿå ÿ≥ÿ±ÿπÿ™ ÿ´ÿßÿ®ÿ™ ÿ®ÿ±ŸÖ€å‚Äå⁄Øÿ±ÿØÿßŸÜ€åŸÖ
        return 100.0
    
    def calculate_score(self, result: Dict) -> float:
        """ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿßŸÖÿ™€åÿßÿ≤ ⁄©ÿßŸÜŸÅ€å⁄Ø ÿ®ÿ± ÿßÿ≥ÿßÿ≥ latency Ÿà ÿ≥ÿ±ÿπÿ™"""
        if not result["success"]:
            return 0.0
        
        latency_score = max(0, 100 - result["latency"] / 10)  # Ÿáÿ± 10ms = 1 ÿßŸÖÿ™€åÿßÿ≤ ⁄©ŸÖÿ™ÿ±
        speed_score = min(100, result["download_speed"] / 10)  # Ÿáÿ± 10 KB/s = 1 ÿßŸÖÿ™€åÿßÿ≤
        
        # Ÿàÿ≤ŸÜ ÿ®€åÿ¥ÿ™ÿ± ÿ®ÿ±ÿß€å latency
        final_score = (latency_score * 0.7) + (speed_score * 0.3)
        return final_score
    
    async def test_all_configs(self, configs: List[str]) -> List[Dict]:
        """ÿ™ÿ≥ÿ™ ÿ™ŸÖÿßŸÖ ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß"""
        logging.info(f"ÿ¥ÿ±Ÿàÿπ ÿ™ÿ≥ÿ™ {len(configs)} ⁄©ÿßŸÜŸÅ€å⁄Ø...")
        
        semaphore = asyncio.Semaphore(CONCURRENT_TESTS)
        
        async def test_single_config(config: str) -> Dict:
            async with semaphore:
                try:
                    return await self.test_config_connection(config)
                except Exception as e:
                    return {
                        "config": config,
                        "hash": self.create_config_hash(config),
                        "success": False,
                        "latency": None,
                        "download_speed": None,
                        "error": str(e),
                        "protocol": self.get_protocol(config)
                    }
        
        tasks = [test_single_config(config) for config in configs]
        results = await asyncio.gather(*tasks, return_exceptions=False)
        
        successful_count = sum(1 for r in results if r.get("success"))
        logging.info(f"ÿ™ÿ≥ÿ™ ⁄©ÿßŸÖŸÑ ÿ¥ÿØ: {successful_count} ⁄©ÿßŸÜŸÅ€å⁄Ø ŸÖŸàŸÅŸÇ ÿßÿ≤ {len(configs)}")
        return results
    
    def select_best_configs(self, results: List[Dict]) -> List[str]:
        """ÿßŸÜÿ™ÿÆÿßÿ® ÿ®Ÿáÿ™ÿ±€åŸÜ ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß"""
        # ŸÖÿ≠ÿßÿ≥ÿ®Ÿá ÿßŸÖÿ™€åÿßÿ≤ ÿ®ÿ±ÿß€å Ÿáÿ± ⁄©ÿßŸÜŸÅ€å⁄Ø
        scored_configs = []
        for result in results:
            score = self.calculate_score(result)
            scored_configs.append((result["config"], score))
        
        # ŸÖÿ±ÿ™ÿ®‚Äåÿ≥ÿßÿ≤€å ÿ®ÿ± ÿßÿ≥ÿßÿ≥ ÿßŸÖÿ™€åÿßÿ≤ (ŸÜÿ≤ŸàŸÑ€å)
        scored_configs.sort(key=lambda x: x[1], reverse=True)
        
        # ÿßŸÜÿ™ÿÆÿßÿ® ÿ®Ÿáÿ™ÿ±€åŸÜ KEEP_BEST_COUNT ⁄©ÿßŸÜŸÅ€å⁄Ø
        best_configs = scored_configs[:KEEP_BEST_COUNT]
        
        logging.info(f"ÿ®Ÿáÿ™ÿ±€åŸÜ {len(best_configs)} ⁄©ÿßŸÜŸÅ€å⁄Ø ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØŸÜÿØ:")
        for i, (config, score) in enumerate(best_configs, 1):
            config_hash = self.create_config_hash(config)
            logging.info(f"{i}. {config_hash} - Score: {score:.1f}")
        
        return [config for config, score in best_configs]
    
    def save_tested_configs(self, best_configs: List[str]):
        """ÿ∞ÿÆ€åÿ±Ÿá ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß€å ÿ™ÿ≥ÿ™ ÿ¥ÿØŸá"""
        try:
            with open(TESTED_FILE, 'w', encoding='utf-8') as f:
                for config in best_configs:
                    f.write(f"{config}\n")
            
            logging.info(f"ŸÅÿß€åŸÑ {TESTED_FILE} ÿ®ÿß {len(best_configs)} ⁄©ÿßŸÜŸÅ€å⁄Ø ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ")
            
        except Exception as e:
            logging.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿ∞ÿÆ€åÿ±Ÿá ŸÅÿß€åŸÑ ÿ™ÿ≥ÿ™ ÿ¥ÿØŸá: {e}")
    
    def save_test_results(self, results: List[Dict], best_configs: List[str]):
        """ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿ™ÿß€åÿ¨ ÿ™ÿ≥ÿ™"""
        try:
            test_stats = {
                "timestamp": datetime.now().isoformat(),
                "total_configs": len(results),
                "successful": len([r for r in results if r["success"]]),
                "failed": len([r for r in results if not r["success"]]),
                "best_configs": len(best_configs),
                "protocol_stats": {},
                "last_test_stats": {
                    "total_configs": len(results),
                    "successful": len([r for r in results if r["success"]]),
                    "failed": len([r for r in results if not r["success"]]),
                    "best_configs": len(best_configs)
                }
            }
            
            # ÿ¢ŸÖÿßÿ± Ÿæÿ±Ÿàÿ™⁄©ŸÑ‚ÄåŸáÿß
            for result in results:
                protocol = result["protocol"]
                if protocol not in test_stats["protocol_stats"]:
                    test_stats["protocol_stats"][protocol] = {"total": 0, "successful": 0}
                test_stats["protocol_stats"][protocol]["total"] += 1
                if result["success"]:
                    test_stats["protocol_stats"][protocol]["successful"] += 1
            
            with open(TEST_RESULTS_FILE, 'w', encoding='utf-8') as f:
                json.dump(test_stats, f, indent=2, ensure_ascii=False)
            
            logging.info(f"ŸÜÿ™ÿß€åÿ¨ ÿ™ÿ≥ÿ™ ÿØÿ± {TEST_RESULTS_FILE} ÿ∞ÿÆ€åÿ±Ÿá ÿ¥ÿØ")
            
        except Exception as e:
            logging.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿ™ÿß€åÿ¨ ÿ™ÿ≥ÿ™: {e}")
    
    async def run_daily_test(self) -> bool:
        """ÿßÿ¨ÿ±ÿß€å ÿ™ÿ≥ÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá"""
        try:
            logging.info("=" * 60)
            logging.info("üöÄ ÿ¥ÿ±Ÿàÿπ ÿ™ÿ≥ÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá TrustLink")
            logging.info("=" * 60)
            
            # ÿ®ÿ±ÿ±ÿ≥€å ÿ≠ÿ∂Ÿàÿ± Xray ÿ®ÿ±ÿß€å ŸÑÿß⁄Ø (ÿßÿÆÿ™€åÿßÿ±€å)
            self.ensure_xray_binary()
            
            # ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß
            configs = self.load_trustlink_configs()
            if not configs:
                logging.error("‚ùå Ÿá€å⁄Ü ⁄©ÿßŸÜŸÅ€å⁄Ø€å ÿ®ÿ±ÿß€å ÿ™ÿ≥ÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ")
                return False
            
            # ÿß€åÿ¨ÿßÿØ session
            await self.create_session()
            
            # ÿ™ÿ≥ÿ™ ÿ™ŸÖÿßŸÖ ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß
            results = await self.test_all_configs(configs)
            
            successful_results = [r for r in results if r.get("success")]
            if not successful_results:
                logging.warning("‚ö†Ô∏è Ÿá€å⁄Ü ⁄©ÿßŸÜŸÅ€å⁄Ø ŸÖŸàŸÅŸÇ€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ")
                # ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿ™ÿß€åÿ¨ ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ÿ±ÿß€å ⁄Øÿ≤ÿßÿ±ÿ¥‚Äå⁄Ø€åÿ±€å
                self.save_test_results(results, [])
                return False
            
            # ÿßŸÜÿ™ÿÆÿßÿ® ÿ®Ÿáÿ™ÿ±€åŸÜ ⁄©ÿßŸÜŸÅ€å⁄Ø‚ÄåŸáÿß ÿßÿ≤ ÿ®€åŸÜ ŸÖŸàŸÅŸÇ‚ÄåŸáÿß
            best_configs = self.select_best_configs(successful_results)
            
            # ÿ∞ÿÆ€åÿ±Ÿá ŸÜÿ™ÿß€åÿ¨
            self.save_tested_configs(best_configs)
            self.save_test_results(results, best_configs)
            
            logging.info("=" * 60)
            logging.info("‚úÖ ÿ™ÿ≥ÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ⁄©ÿßŸÖŸÑ ÿ¥ÿØ")
            logging.info(f"üìä ÿ¢ŸÖÿßÿ±: {len(results)} ÿ™ÿ≥ÿ™ ÿ¥ÿØŸáÿå {len(best_configs)} ÿßŸÜÿ™ÿÆÿßÿ® ÿ¥ÿØŸá")
            logging.info("=" * 60)
            
            return True
            
        except Exception as e:
            logging.error(f"ÿÆÿ∑ÿß ÿØÿ± ÿßÿ¨ÿ±ÿß€å ÿ™ÿ≥ÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá: {e}")
            return False
        finally:
            await self.close_session()

async def main():
    """ÿ™ÿßÿ®ÿπ ÿßÿµŸÑ€å ÿ®ÿ±ŸÜÿßŸÖŸá"""
    tester = DailyTrustLinkTester()
    
    try:
        # ÿßÿ¨ÿ±ÿß€å ÿ™ÿ≥ÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá ÿ®ÿß timeout
        success = await asyncio.wait_for(tester.run_daily_test(), timeout=600)  # timeout 10 ÿØŸÇ€åŸÇŸá
        
        if success:
            logging.info("üéâ ÿ™ÿ≥ÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿßŸÜÿ¨ÿßŸÖ ÿ¥ÿØ")
            sys.exit(0)
        else:
            logging.error("‚ùå ÿ™ÿ≥ÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá ŸÜÿßŸÖŸàŸÅŸÇ ÿ®ŸàÿØ")
            sys.exit(1)
            
    except asyncio.TimeoutError:
        logging.error("‚è∞ timeout: ÿ™ÿ≥ÿ™ ÿ®€åÿ¥ ÿßÿ≤ 10 ÿØŸÇ€åŸÇŸá ÿ∑ŸàŸÑ ⁄©ÿ¥€åÿØ")
        sys.exit(1)
    except KeyboardInterrupt:
        logging.info("ÿ®ÿ±ŸÜÿßŸÖŸá ÿ™Ÿàÿ≥ÿ∑ ⁄©ÿßÿ±ÿ®ÿ± ŸÖÿ™ŸàŸÇŸÅ ÿ¥ÿØ")
        sys.exit(1)
    except Exception as e:
        logging.error(f"ÿÆÿ∑ÿß€å ÿ∫€åÿ±ŸÖŸÜÿ™ÿ∏ÿ±Ÿá: {e}")
        sys.exit(1)

if __name__ == "__main__":
    asyncio.run(main())
